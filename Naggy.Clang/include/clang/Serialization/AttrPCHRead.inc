// This file is generated by TableGen. Do not edit.

  switch (Kind) {
  default:
    assert(0 && "Unknown attribute!");
    break;
  case attr::Alias: {
    bool isInherited = Record[Idx++];
    std::string aliasee= ReadString(Record, Idx);
    New = new (*Context) AliasAttr(Loc, *Context, aliasee);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::AlignMac68k: {
    bool isInherited = Record[Idx++];
    New = new (*Context) AlignMac68kAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Aligned: {
    bool isInherited = Record[Idx++];
    bool isalignmentExpr = Record[Idx++];
    void *alignmentPtr;
    if (isalignmentExpr)
      alignmentPtr = ReadExpr(F);
    else
      alignmentPtr = GetTypeSourceInfo(F, Record, Idx);
    New = new (*Context) AlignedAttr(Loc, *Context, isalignmentExpr, alignmentPtr);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::AlwaysInline: {
    bool isInherited = Record[Idx++];
    New = new (*Context) AlwaysInlineAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::AnalyzerNoReturn: {
    bool isInherited = Record[Idx++];
    New = new (*Context) AnalyzerNoReturnAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Annotate: {
    bool isInherited = Record[Idx++];
    std::string annotation= ReadString(Record, Idx);
    New = new (*Context) AnnotateAttr(Loc, *Context, annotation);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::AsmLabel: {
    bool isInherited = Record[Idx++];
    std::string label= ReadString(Record, Idx);
    New = new (*Context) AsmLabelAttr(Loc, *Context, label);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Availability: {
    bool isInherited = Record[Idx++];
    IdentifierInfo * platform = GetIdentifierInfo(Record, Idx);
    VersionTuple introduced= ReadVersionTuple(Record, Idx);
    VersionTuple deprecated= ReadVersionTuple(Record, Idx);
    VersionTuple obsoleted= ReadVersionTuple(Record, Idx);
    bool unavailable = Record[Idx++];
    New = new (*Context) AvailabilityAttr(Loc, *Context, platform, introduced, deprecated, obsoleted, unavailable);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Blocks: {
    bool isInherited = Record[Idx++];
    BlocksAttr::BlockType type(static_cast<BlocksAttr::BlockType>(Record[Idx++]));
    New = new (*Context) BlocksAttr(Loc, *Context, type);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::CDecl: {
    bool isInherited = Record[Idx++];
    New = new (*Context) CDeclAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::CFConsumed: {
    bool isInherited = Record[Idx++];
    New = new (*Context) CFConsumedAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::CFReturnsNotRetained: {
    bool isInherited = Record[Idx++];
    New = new (*Context) CFReturnsNotRetainedAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::CFReturnsRetained: {
    bool isInherited = Record[Idx++];
    New = new (*Context) CFReturnsRetainedAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::CUDAConstant: {
    bool isInherited = Record[Idx++];
    New = new (*Context) CUDAConstantAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::CUDADevice: {
    New = new (*Context) CUDADeviceAttr(Loc, *Context);
    break;
  }
  case attr::CUDAGlobal: {
    bool isInherited = Record[Idx++];
    New = new (*Context) CUDAGlobalAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::CUDAHost: {
    New = new (*Context) CUDAHostAttr(Loc, *Context);
    break;
  }
  case attr::CUDALaunchBounds: {
    bool isInherited = Record[Idx++];
    int maxThreads = Record[Idx++];
    int minBlocks = Record[Idx++];
    New = new (*Context) CUDALaunchBoundsAttr(Loc, *Context, maxThreads, minBlocks);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::CUDAShared: {
    bool isInherited = Record[Idx++];
    New = new (*Context) CUDASharedAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::CarriesDependency: {
    bool isInherited = Record[Idx++];
    New = new (*Context) CarriesDependencyAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Cleanup: {
    bool isInherited = Record[Idx++];
    FunctionDecl * functionDecl = cast_or_null<FunctionDecl >(GetDecl(Record[Idx++]));
    New = new (*Context) CleanupAttr(Loc, *Context, functionDecl);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Common: {
    bool isInherited = Record[Idx++];
    New = new (*Context) CommonAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Const: {
    bool isInherited = Record[Idx++];
    New = new (*Context) ConstAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Constructor: {
    bool isInherited = Record[Idx++];
    int priority = Record[Idx++];
    New = new (*Context) ConstructorAttr(Loc, *Context, priority);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::DLLExport: {
    bool isInherited = Record[Idx++];
    New = new (*Context) DLLExportAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::DLLImport: {
    bool isInherited = Record[Idx++];
    New = new (*Context) DLLImportAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Deprecated: {
    bool isInherited = Record[Idx++];
    std::string message= ReadString(Record, Idx);
    New = new (*Context) DeprecatedAttr(Loc, *Context, message);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Destructor: {
    bool isInherited = Record[Idx++];
    int priority = Record[Idx++];
    New = new (*Context) DestructorAttr(Loc, *Context, priority);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::FastCall: {
    bool isInherited = Record[Idx++];
    New = new (*Context) FastCallAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Final: {
    bool isInherited = Record[Idx++];
    New = new (*Context) FinalAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Format: {
    bool isInherited = Record[Idx++];
    std::string type= ReadString(Record, Idx);
    int formatIdx = Record[Idx++];
    int firstArg = Record[Idx++];
    New = new (*Context) FormatAttr(Loc, *Context, type, formatIdx, firstArg);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::FormatArg: {
    bool isInherited = Record[Idx++];
    int formatIdx = Record[Idx++];
    New = new (*Context) FormatArgAttr(Loc, *Context, formatIdx);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::GNUInline: {
    bool isInherited = Record[Idx++];
    New = new (*Context) GNUInlineAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::IBAction: {
    bool isInherited = Record[Idx++];
    New = new (*Context) IBActionAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::IBOutlet: {
    bool isInherited = Record[Idx++];
    New = new (*Context) IBOutletAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::IBOutletCollection: {
    bool isInherited = Record[Idx++];
    QualType interFace = GetType(Record[Idx++]);
    New = new (*Context) IBOutletCollectionAttr(Loc, *Context, interFace);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::InitPriority: {
    bool isInherited = Record[Idx++];
    unsigned priority = Record[Idx++];
    New = new (*Context) InitPriorityAttr(Loc, *Context, priority);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::MBlazeInterruptHandler: {
    bool isInherited = Record[Idx++];
    New = new (*Context) MBlazeInterruptHandlerAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::MBlazeSaveVolatiles: {
    bool isInherited = Record[Idx++];
    New = new (*Context) MBlazeSaveVolatilesAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::MSP430Interrupt: {
    bool isInherited = Record[Idx++];
    unsigned number = Record[Idx++];
    New = new (*Context) MSP430InterruptAttr(Loc, *Context, number);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Malloc: {
    bool isInherited = Record[Idx++];
    New = new (*Context) MallocAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::MaxFieldAlignment: {
    bool isInherited = Record[Idx++];
    unsigned alignment = Record[Idx++];
    New = new (*Context) MaxFieldAlignmentAttr(Loc, *Context, alignment);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::MayAlias: {
    bool isInherited = Record[Idx++];
    New = new (*Context) MayAliasAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::MsStruct: {
    bool isInherited = Record[Idx++];
    New = new (*Context) MsStructAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::NSConsumed: {
    bool isInherited = Record[Idx++];
    New = new (*Context) NSConsumedAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::NSConsumesSelf: {
    bool isInherited = Record[Idx++];
    New = new (*Context) NSConsumesSelfAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::NSReturnsAutoreleased: {
    bool isInherited = Record[Idx++];
    New = new (*Context) NSReturnsAutoreleasedAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::NSReturnsNotRetained: {
    bool isInherited = Record[Idx++];
    New = new (*Context) NSReturnsNotRetainedAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::NSReturnsRetained: {
    bool isInherited = Record[Idx++];
    New = new (*Context) NSReturnsRetainedAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Naked: {
    bool isInherited = Record[Idx++];
    New = new (*Context) NakedAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::NoCommon: {
    bool isInherited = Record[Idx++];
    New = new (*Context) NoCommonAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::NoDebug: {
    bool isInherited = Record[Idx++];
    New = new (*Context) NoDebugAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::NoInline: {
    bool isInherited = Record[Idx++];
    New = new (*Context) NoInlineAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::NoInstrumentFunction: {
    bool isInherited = Record[Idx++];
    New = new (*Context) NoInstrumentFunctionAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::NoReturn: {
    bool isInherited = Record[Idx++];
    New = new (*Context) NoReturnAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::NoThrow: {
    bool isInherited = Record[Idx++];
    New = new (*Context) NoThrowAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::NonNull: {
    bool isInherited = Record[Idx++];
  unsigned argsSize = Record[Idx++];
  llvm::SmallVector<unsigned, 4> args;
  args.reserve(argsSize);
  for (unsigned i = argsSize; i; --i)
    args.push_back(Record[Idx++]);
    New = new (*Context) NonNullAttr(Loc, *Context, args.data(), argsSize);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::ObjCException: {
    bool isInherited = Record[Idx++];
    New = new (*Context) ObjCExceptionAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::ObjCMethodFamily: {
    bool isInherited = Record[Idx++];
    ObjCMethodFamilyAttr::FamilyKind family(static_cast<ObjCMethodFamilyAttr::FamilyKind>(Record[Idx++]));
    New = new (*Context) ObjCMethodFamilyAttr(Loc, *Context, family);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::ObjCNSObject: {
    bool isInherited = Record[Idx++];
    New = new (*Context) ObjCNSObjectAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::OpenCLKernel: {
    New = new (*Context) OpenCLKernelAttr(Loc, *Context);
    break;
  }
  case attr::Overloadable: {
    New = new (*Context) OverloadableAttr(Loc, *Context);
    break;
  }
  case attr::Override: {
    bool isInherited = Record[Idx++];
    New = new (*Context) OverrideAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Ownership: {
    bool isInherited = Record[Idx++];
    OwnershipAttr::OwnershipKind ownKind(static_cast<OwnershipAttr::OwnershipKind>(Record[Idx++]));
    std::string module= ReadString(Record, Idx);
  unsigned argsSize = Record[Idx++];
  llvm::SmallVector<unsigned, 4> args;
  args.reserve(argsSize);
  for (unsigned i = argsSize; i; --i)
    args.push_back(Record[Idx++]);
    New = new (*Context) OwnershipAttr(Loc, *Context, ownKind, module, args.data(), argsSize);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Packed: {
    bool isInherited = Record[Idx++];
    New = new (*Context) PackedAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Pascal: {
    bool isInherited = Record[Idx++];
    New = new (*Context) PascalAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Pcs: {
    bool isInherited = Record[Idx++];
    PcsAttr::PCSType pCS(static_cast<PcsAttr::PCSType>(Record[Idx++]));
    New = new (*Context) PcsAttr(Loc, *Context, pCS);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Pure: {
    bool isInherited = Record[Idx++];
    New = new (*Context) PureAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Regparm: {
    bool isInherited = Record[Idx++];
    unsigned numParams = Record[Idx++];
    New = new (*Context) RegparmAttr(Loc, *Context, numParams);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::ReqdWorkGroupSize: {
    bool isInherited = Record[Idx++];
    unsigned xDim = Record[Idx++];
    unsigned yDim = Record[Idx++];
    unsigned zDim = Record[Idx++];
    New = new (*Context) ReqdWorkGroupSizeAttr(Loc, *Context, xDim, yDim, zDim);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Section: {
    bool isInherited = Record[Idx++];
    std::string name= ReadString(Record, Idx);
    New = new (*Context) SectionAttr(Loc, *Context, name);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Sentinel: {
    bool isInherited = Record[Idx++];
    int sentinel = Record[Idx++];
    int nullPos = Record[Idx++];
    New = new (*Context) SentinelAttr(Loc, *Context, sentinel, nullPos);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::StdCall: {
    bool isInherited = Record[Idx++];
    New = new (*Context) StdCallAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::ThisCall: {
    bool isInherited = Record[Idx++];
    New = new (*Context) ThisCallAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::TransparentUnion: {
    bool isInherited = Record[Idx++];
    New = new (*Context) TransparentUnionAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Unavailable: {
    bool isInherited = Record[Idx++];
    std::string message= ReadString(Record, Idx);
    New = new (*Context) UnavailableAttr(Loc, *Context, message);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Unused: {
    bool isInherited = Record[Idx++];
    New = new (*Context) UnusedAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Used: {
    bool isInherited = Record[Idx++];
    New = new (*Context) UsedAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Uuid: {
    bool isInherited = Record[Idx++];
    std::string guid= ReadString(Record, Idx);
    New = new (*Context) UuidAttr(Loc, *Context, guid);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::VecReturn: {
    bool isInherited = Record[Idx++];
    New = new (*Context) VecReturnAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Visibility: {
    bool isInherited = Record[Idx++];
    VisibilityAttr::VisibilityType visibility(static_cast<VisibilityAttr::VisibilityType>(Record[Idx++]));
    New = new (*Context) VisibilityAttr(Loc, *Context, visibility);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::WarnUnusedResult: {
    bool isInherited = Record[Idx++];
    New = new (*Context) WarnUnusedResultAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::Weak: {
    bool isInherited = Record[Idx++];
    New = new (*Context) WeakAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::WeakImport: {
    bool isInherited = Record[Idx++];
    New = new (*Context) WeakImportAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::WeakRef: {
    bool isInherited = Record[Idx++];
    New = new (*Context) WeakRefAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  case attr::X86ForceAlignArgPointer: {
    bool isInherited = Record[Idx++];
    New = new (*Context) X86ForceAlignArgPointerAttr(Loc, *Context);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    break;
  }
  }
